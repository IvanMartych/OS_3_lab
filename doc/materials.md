# Материалы по виртуальной памяти, shared memory и смежным темам

## 1. Виртуальная память

### Основная концепция

Виртуальная память — это механизм, который создает для каждого процесса иллюзию, что у него есть собственное огромное адресное пространство, не зависящее от других процессов и физической памяти.

### Ключевые особенности:

- **Изоляция процессов**: Каждый процесс работает в своем "виртуальном мире"
- **Безопасность**: Процессы не могут случайно повредить память друг друга
- **Упрощение программирования**: Программист работает с "плоским" адресным пространством

### Как работает:

- Каждый процесс имеет свое виртуальное адресное пространство
- ОС и MMU (Memory Management Unit) переводят виртуальные адреса в физические
- Данные могут находиться в RAM, файле подкачки или исходных файлах

## 2. Memory Mapped Files (Shared Memory)

### Что это?

Механизм, позволяющий отобразить содержимое файла (или блока памяти) прямо в виртуальную память процесса.

### Для чего используется:

1. **Межпроцессное взаимодействие (IPC)** — самый быстрый способ обмена данными
2. **Работа с большими файлами** — ускорение доступа к данным

### Как работает для IPC:

- Несколько процессов отображают один и тот же регион файла
- Изменения, сделанные одним процессом, сразу видны другим
- Данные физически находятся в одном месте, но доступны через разные виртуальные адреса

### Пример на Windows API:

```c
// Создание File Mapping
HANDLE hMap = CreateFileMapping(INVALID_HANDLE_VALUE, ...);

// Проецирование в память
void* data = MapViewOfFile(hMap, ...);
```

## 3. Файлы подкачки (Page File/Swap File)

### Назначение

Файл подкачки — это специальный файл на диске, который ОС использует как "расширение" оперативной памяти.

### Механизм работы:

- Когда RAM переполняется, ОС выгружает неактивные страницы памяти на диск
- При обращении к выгруженным данным, ОС загружает их обратно в RAM
- Процесс не знает, где физически находятся его данные

### Важно:

- Файл подкачки ≠ Виртуальная память
- Файл подкачки — это реализация части механизма виртуальной памяти
- Анонимные Memory Mapped Files хранятся в файле подкачки

## 4. Таблицы страниц (Page Tables) и MMU

### Таблицы страниц

- **У каждого процесса своя таблица страниц**
- Содержит переводы: виртуальные адреса → физические адреса
- Хранится в оперативной памяти

### MMU (Memory Management Unit)

- Специальный аппаратный компонент внутри процессора
- Отвечает за преобразование виртуальных адресов в физические
- Использует TLB (Translation Lookaside Buffer) для кэширования частых переводов

### Процесс доступа к памяти:

```
Виртуальный адрес → MMU → Таблица страниц → Физический адрес → Данные
```

## 5. Механизм отображения для процессов

### Как процессы видят общую память:

```
Процесс A: 0x00100000 → Физический адрес X
Процесс B: 0x00500000 → Тот же физический адрес X
```

### Ключевые моменты:

- Виртуальные адреса могут быть разными в разных процессах
- Физические адреса одинаковые для общей памяти
- ОС настраивает таблицы страниц процессов соответствующим образом

## 6. Синхронизация процессов

### Почему важна:

- При работе с общей памятью возможны состояния гонки (race conditions)
- Необходимо координировать доступ к общим данным

### Механизмы синхронизации:

- **События (Events)** — для уведомления о наличии данных
- **Мьютексы (Mutexes)** — для защиты критических секций
- **Семафоры (Semaphores)** — для ограничения доступа к ресурсам

## 7. Историческая перспектива

### До виртуальной памяти:

- Прямой доступ к физической памяти
- Нет изоляции между процессами
- Сложное управление памятью

### Развитие:

- 1962: Atlas Computer — первая система с виртуальной памятью
- 1970-е: Появление в мейнфреймах
- 1990-е: Стала стандартом для персональных компьютеров

## 8. Практическое применение в лабораторной работе

### Архитектура решения

В данной лабораторной работе реализована система межпроцессного взаимодействия, где родительский процесс собирает числовые данные от пользователя и передает их дочернему процессу для обработки. Дочерний процесс вычисляет суммы чисел и записывает результаты в файл. Для обмена данными используется механизм shared memory на базе POSIX API.

### Типичная последовательность работы:

1. **Создание File Mapping объекта** — родительский процесс создает именованную область shared memory
2. **Проецирование в память родительского процесса** — отображение shared memory в адресное пространство
3. **Создание/запуск дочернего процесса** — порождение дочернего процесса через fork() и exec()
4. **Открытие того же File Mapping в дочернем процессе** — дочерний процесс получает доступ к той же области памяти
5. **Синхронизация доступа** — координация чтения/записи через флаги в shared memory
6. **Работа с общей памятью** — передача данных и их обработка
7. **Освобождение ресурсов** — корректное завершение и очистка

### Преимущества подхода:

- **Высокая скорость обмена данными** — нет копирования через ядро ОС
- **Естественная работа с данными** — доступ как к обычной памяти через указатели
- **Поддержка больших объемов данных** — можно передавать мегабайты информации
- **Гибкость** — можно передавать сложные структуры данных

### Детальный разбор реализации (POSIX API)

#### Этап 1: Проектирование структуры данных

Первым шагом необходимо спроектировать структуру данных, которая будет храниться в shared memory. В нашем случае это структура `shared_data_t`, содержащая буфер для данных и флаг синхронизации:

```c
#define SHM_SIZE 4096  // Размер shared memory (4 КБ)

typedef struct {
    char data[SHM_SIZE - 4];  // Буфер для передачи данных
    int data_ready;           // Флаг синхронизации:
                              // 0 - данные не готовы (можно писать)
                              // 1 - данные готовы к чтению
                              // 2 - конец передачи данных
} shared_data_t;
```

**Важные моменты проектирования:**

- Размер буфера данных уменьшен на 4 байта для размещения флага `data_ready`
- Флаг `data_ready` используется для простой синхронизации без дополнительных примитивов
- Общий размер структуры не превышает SHM_SIZE (4096 байт)

#### Этап 2: Создание shared memory в родительском процессе

Родительский процесс отвечает за создание и инициализацию области shared memory. Этот процесс состоит из нескольких критически важных шагов:

```c
// Сначала удаляем старый объект, если он существует
shm_unlink("/numbers_shm");

// Создаем новый shared memory объект
int shm_fd = shm_open("/numbers_shm",           // Имя объекта
                      O_RDWR | O_CREAT | O_EXCL, // Флаги: чтение-запись, создать, эксклюзивно
                      0644);                      // Права доступа: rw-r--r--

if (shm_fd == -1) {
    // Обработка ошибки создания
    perror("shm_open failed");
    return 1;
}
```

**Объяснение флагов:**

- `O_RDWR` — открываем для чтения и записи
- `O_CREAT` — создаем объект, если он не существует
- `O_EXCL` — гарантирует, что мы создаем новый объект (ошибка, если уже существует)
- `0644` — права доступа: владелец может читать/писать, остальные только читать

```c
// Устанавливаем размер shared memory области
if (ftruncate(shm_fd, SHM_SIZE) == -1) {
    perror("ftruncate failed");
    shm_unlink("/numbers_shm");
    return 1;
}
```

**Зачем нужен ftruncate():**
Вновь созданный shared memory объект имеет нулевой размер. Функция `ftruncate()` устанавливает размер области памяти. Без этого вызова `mmap()` не сможет отобразить память.

```c
// Отображаем shared memory в адресное пространство процесса
shared_data_t* shared_data = mmap(
    NULL,              // Адрес: NULL означает, что ОС выберет адрес сама
    SHM_SIZE,          // Размер отображаемой области
    PROT_READ | PROT_WRITE,  // Права: чтение и запись
    MAP_SHARED,        // Тип: разделяемая память (изменения видны другим)
    shm_fd,            // Дескриптор shared memory объекта
    0                  // Смещение: начинаем с начала объекта
);

if (shared_data == MAP_FAILED) {
    perror("mmap failed");
    shm_unlink("/numbers_shm");
    return 1;
}
```

**Что происходит при mmap():**

1. ОС находит свободное место в виртуальном адресном пространстве процесса
2. ОС добавляет записи в таблицу страниц процесса
3. Виртуальные адреса связываются с физическими страницами shared memory
4. Возвращается указатель на начало отображенной области

```c
// Инициализация shared memory
shared_data->data_ready = 0;      // Изначально данные не готовы
shared_data->data[0] = '\0';      // Пустая строка в буфере
```

**Зачем нужна инициализация:**
Содержимое новой shared memory области не определено (может содержать мусор). Инициализация гарантирует предсказуемое начальное состояние.

#### Этап 3: Доступ к shared memory в дочернем процессе

Дочерний процесс создается через `fork()` и затем заменяется новой программой через `execl()`. Важно понимать, что после `exec()` дочерний процесс теряет все отображения памяти родителя, поэтому ему необходимо заново открыть и отобразить shared memory:

```c
// Открываем существующий shared memory объект
int shm_fd = shm_open("/numbers_shm",  // То же имя, что использовал родитель
                      O_RDWR,           // Только чтение-запись, без O_CREAT
                      0644);            // Права (игнорируются при открытии)

if (shm_fd == -1) {
    perror("Child: shm_open failed");
    return 1;
}
```

**Ключевое отличие от родителя:**

- Нет флага `O_CREAT` — мы открываем существующий объект
- Нет флага `O_EXCL` — объект должен уже существовать
- Нет вызова `ftruncate()` — размер уже установлен родителем

```c
// Отображаем shared memory в адресное пространство дочернего процесса
shared_data_t* shared_data = mmap(
    NULL,                    // ОС выберет адрес (может отличаться от родителя!)
    SHM_SIZE,                // Тот же размер
    PROT_READ | PROT_WRITE,  // Те же права
    MAP_SHARED,              // MAP_SHARED критически важен!
    shm_fd,                  // Дескриптор shared memory
    0                        // С начала объекта
);

if (shared_data == MAP_FAILED) {
    perror("Child: mmap failed");
    close(shm_fd);
    return 1;
}

// Теперь оба процесса видят одни и те же физические данные!
```

**Магия виртуальной памяти:**

```
Родительский процесс:                 Дочерний процесс:
Виртуальный адрес: 0x7f8a2c000000     Виртуальный адрес: 0x7f9b3d000000
         ↓                                     ↓
         └─────────→ Физическая память ←──────┘
                      (одна и та же область)
```

Хотя виртуальные адреса `shared_data` в родительском и дочернем процессах могут быть разными, они указывают на одну и ту же физическую память. Это ключевая особенность виртуальной памяти и shared memory.

#### Этап 4: Протокол синхронизации через флаги

Поскольку оба процесса имеют доступ к одной и той же памяти, возникает проблема координации: как избежать ситуации, когда один процесс перезаписывает данные, которые другой еще не прочитал? В нашей реализации используется простой, но эффективный протокол на основе флага `data_ready`.

**Протокол работы:**

```
Состояние 0: Буфер свободен, родитель может писать
    ↓ (родитель пишет данные)
Состояние 1: Данные готовы к чтению дочерним процессом
    ↓ (дочерний процесс читает и обрабатывает)
Состояние 0: Дочерний подтверждает чтение, родитель может писать снова
    ↓ (цикл повторяется)
Состояние 2: Родитель сигнализирует о завершении передачи
```

**Реализация в родительском процессе:**

```c
while (1) {
    // 1. Получаем данные от пользователя
    printf("> ");
    fgets(buffer, sizeof(buffer), stdin);

    // 2. Ждем, пока дочерний процесс прочитает предыдущие данные
    // Активное ожидание с паузами для экономии CPU
    while (shared_data->data_ready == 1) {
        usleep(1000);  // Спим 1 миллисекунду между проверками
    }

    // 3. Теперь безопасно писать: дочерний процесс не читает
    strncpy(shared_data->data, buffer, sizeof(shared_data->data) - 1);
    shared_data->data[sizeof(shared_data->data) - 1] = '\0';

    // 4. Помечаем данные как готовые к чтению
    shared_data->data_ready = 1;

    // 5. Проверка на завершение (пустая строка)
    if (buffer[0] == '\n') {
        shared_data->data_ready = 2;  // Сигнал завершения
        break;
    }
}
```

**Реализация в дочернем процессе:**

```c
while (1) {
    // 1. Ждем появления новых данных от родителя
    while (shared_data->data_ready == 0) {
        usleep(1000);  // Спим между проверками
    }

    // 2. Проверяем, не сигнал ли это о завершении
    if (shared_data->data_ready == 2) {
        break;  // Выходим из цикла
    }

    // 3. Копируем данные из shared memory в локальный буфер
    // Это позволяет родителю быстрее записать следующую порцию
    char local_buffer[1024];
    strncpy(local_buffer, shared_data->data, sizeof(local_buffer) - 1);
    local_buffer[sizeof(local_buffer) - 1] = '\0';

    // 4. Сразу подтверждаем чтение
    shared_data->data_ready = 0;

    // 5. Теперь можем спокойно обрабатывать данные
    // Родитель уже может писать следующую порцию
    process_numbers(local_buffer);
}
```

**Почему этот подход работает:**

1. **Взаимное исключение**: Только один процесс может писать/читать в данный момент
2. **Буферизация**: Дочерний процесс копирует данные локально, освобождая буфер
3. **Сигнализация**: Флаг четко указывает состояние буфера
4. **Энергоэффективность**: `usleep()` предотвращает 100% загрузку CPU

**Альтернативные подходы:**

- Семафоры POSIX (`sem_open`, `sem_wait`, `sem_post`) — более надежно
- Условные переменные — для сложных сценариев
- Mutex + condition variable — полный контроль над синхронизацией

#### Этап 5: Очистка ресурсов и жизненный цикл shared memory

Правильное освобождение ресурсов критически важно для предотвращения утечек памяти и "зависших" shared memory объектов в системе.

**В каждом процессе (родительском и дочернем):**

```c
// 1. Размапливание shared memory из адресного пространства процесса
if (shared_data != MAP_FAILED) {
    if (munmap(shared_data, SHM_SIZE) == -1) {
        perror("munmap failed");
    }
}

// 2. Закрытие файлового дескриптора
if (shm_fd != -1) {
    close(shm_fd);
}
```

**Что делает munmap():**

- Удаляет записи из таблицы страниц процесса
- Виртуальные адреса освобождаются и могут быть использованы заново
- Физическая память НЕ освобождается, пока другие процессы используют shared memory
- После `munmap()` обращение к `shared_data` вызовет segmentation fault

**Только в родительском процессе (после завершения дочернего):**

```c
// Ждем завершения дочернего процесса
int status;
waitpid(pid, &status, 0);

// Удаляем shared memory объект из системы
if (shm_unlink("/numbers_shm") == -1) {
    perror("shm_unlink failed");
}
```

**Что делает shm_unlink():**

- Удаляет имя shared memory объекта из пространства имен системы
- Физическая память освобождается только когда все процессы вызовут `munmap()`
- После `shm_unlink()` новые процессы не смогут открыть этот объект
- Похоже на `unlink()` для файлов

**Жизненный цикл shared memory:**

```
1. Родитель: shm_open() + O_CREAT
   └→ Объект создан в системе, счетчик ссылок = 0

2. Родитель: mmap()
   └→ Счетчик ссылок = 1

3. Дочерний: shm_open() (без O_CREAT)
   └→ Открыт существующий объект

4. Дочерний: mmap()
   └→ Счетчик ссылок = 2

5. Дочерний: munmap()
   └→ Счетчик ссылок = 1, память еще существует

6. Родитель: munmap()
   └→ Счетчик ссылок = 0, но объект еще в системе

7. Родитель: shm_unlink()
   └→ Объект удален, физическая память освобождена
```

**Обработка ошибок и аварийного завершения:**

```c
// Глобальные переменные для cleanup
shared_data_t* shared_data = MAP_FAILED;
int shm_fd = -1;

// Установка обработчика сигналов для корректной очистки
void cleanup_handler(int sig) {
    printf("\nReceived signal %d, cleaning up...\n", sig);

    if (shared_data != MAP_FAILED) {
        munmap(shared_data, SHM_SIZE);
    }

    if (shm_fd != -1) {
        close(shm_fd);
    }

    shm_unlink("/numbers_shm");

    exit(0);
}

// В main():
signal(SIGINT, cleanup_handler);   // Ctrl+C
signal(SIGTERM, cleanup_handler);  // kill
```

Этот обработчик гарантирует, что даже при аварийном завершении (Ctrl+C) ресурсы будут освобождены.

**Проверка существующих shared memory объектов в системе:**

```bash
# Linux: просмотр shared memory объектов
ls -lh /dev/shm/

# Ручное удаление "зависшего" объекта
rm /dev/shm/numbers_shm
```

## 9. Производительность и оптимизация

### TLB (Translation Lookaside Buffer)

- Кэш внутри процессора для хранения последних переводов адресов
- Обеспечивает ~99% попаданий
- Критически важен для производительности

### Иерархия доступа к памяти (от быстрого к медленному):

1. TLB в процессоре
2. Кэш процессора (L1/L2/L3)
3. Оперативная память (RAM)
4. Файл подкачки на SSD
5. Файл подкачки на HDD

## 10. Безопасность и надежность

### Обеспечивается виртуальной памятью:

- Изоляция процессов
- Защита системной памяти
- Контроль прав доступа (read/write/execute)

### Для Memory Mapped Files:

- Контроль доступа через права отображения
- Возможность создания read-only общих регионов

## 11. POSIX Shared Memory API (детальный обзор)

### shm_open()

```c
int shm_open(const char *name, int oflag, mode_t mode);
```

- **name**: Имя shared memory объекта (начинается с `/`)
- **oflag**: Флаги (O_RDWR, O_CREAT, O_EXCL и т.д.)
- **mode**: Права доступа (например, 0644)
- **Возврат**: Дескриптор файла или -1 при ошибке

### ftruncate()

```c
int ftruncate(int fd, off_t length);
```

- Устанавливает размер shared memory объекта
- Необходимо вызывать для новых объектов
- Обязательно перед `mmap()`

### mmap()

```c
void* mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
```

- **addr**: Обычно NULL (ОС выбирает адрес сама)
- **length**: Размер отображаемой области
- **prot**: PROT_READ, PROT_WRITE, PROT_EXEC
- **flags**: MAP_SHARED (общая память) или MAP_PRIVATE (копия)
- **fd**: Дескриптор из shm_open()
- **offset**: Смещение в объекте (обычно 0)

### munmap() и shm_unlink()

```c
int munmap(void *addr, size_t length);  // Размапливание
int shm_unlink(const char *name);      // Удаление объекта
```

## 12. Windows API для Shared Memory

### CreateFileMapping()

```c
HANDLE CreateFileMapping(
    HANDLE hFile,                // INVALID_HANDLE_VALUE для анонимной памяти
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,            // PAGE_READWRITE
    DWORD dwMaximumSizeHigh,    // Старшие 32 бита размера
    DWORD dwMaximumSizeLow,     // Младшие 32 бита размера
    LPCTSTR lpName              // Имя объекта
);
```

### MapViewOfFile()

```c
LPVOID MapViewOfFile(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,      // FILE_MAP_ALL_ACCESS
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap
);
```

### Пример для Windows:

```c
// Создание
HANDLE hMapFile = CreateFileMapping(
    INVALID_HANDLE_VALUE,
    NULL,
    PAGE_READWRITE,
    0,
    4096,
    "Local\\MySharedMemory"
);

// Отображение
char* pBuf = (char*)MapViewOfFile(
    hMapFile,
    FILE_MAP_ALL_ACCESS,
    0,
    0,
    4096
);

// Использование
strcpy(pBuf, "Hello from Windows!");

// Очистка
UnmapViewOfFile(pBuf);
CloseHandle(hMapFile);
```

## 13. Типичные проблемы и их решения

### Race Conditions (Состояния гонки)

**Проблема**: Оба процесса одновременно читают/пишут в shared memory

```c
// НЕПРАВИЛЬНО:
shared_data->counter++; // Не атомарная операция!
```

**Решение**: Использование примитивов синхронизации

```c
// POSIX семафоры
sem_t* sem = sem_open("/my_sem", O_CREAT, 0644, 1);
sem_wait(sem);  // Захват
shared_data->counter++;
sem_post(sem);  // Освобождение
```

### Busy Waiting (Активное ожидание)

**Проблема**: Процесс постоянно проверяет флаг в цикле

```c
while (shared_data->ready == 0) {
    // Пустой цикл - тратит CPU!
}
```

**Решение**: Использование sleep/usleep

```c
while (shared_data->ready == 0) {
    usleep(1000); // Спим 1 мс между проверками
}
```

**Лучшее решение**: Использование условных переменных или событий

### Утечки памяти

**Проблема**: Забыли вызвать `munmap()` или `shm_unlink()`

**Решение**: Всегда освобождайте ресурсы

```c
// В конце программы или при ошибках
if (shared_data != MAP_FAILED) {
    munmap(shared_data, SHM_SIZE);
}
if (shm_fd != -1) {
    close(shm_fd);
}
shm_unlink("/my_shm"); // Только в одном процессе!
```

### Переполнение буфера

**Проблема**: Запись данных больше размера shared memory

**Решение**: Всегда проверяйте границы

```c
strncpy(shared_data->data, input, sizeof(shared_data->data) - 1);
shared_data->data[sizeof(shared_data->data) - 1] = '\0';
```

## 14. Сравнение методов IPC

| Метод              | Скорость      | Сложность | Размер данных | Использование             |
| ------------------ | ------------- | --------- | ------------- | ------------------------- |
| **Pipes**          | Средняя       | Низкая    | Ограничен     | Последовательная передача |
| **Sockets**        | Средняя       | Средняя   | Неограничен   | Сетевое взаимодействие    |
| **Message Queues** | Средняя       | Средняя   | Ограничен     | Асинхронные сообщения     |
| **Shared Memory**  | Очень высокая | Высокая   | Большой       | Массивы, структуры данных |
| **Signals**        | Быстрая       | Низкая    | Нет           | Уведомления               |

### Когда использовать Shared Memory:

✅ Большие объемы данных  
✅ Частый обмен данными  
✅ Низкая задержка критична  
✅ Сложные структуры данных  

❌ Простые команды/уведомления  
❌ Сетевое взаимодействие  
❌ Когда процессы на разных машинах  

## 15. Практические советы

### 1. Проектирование структуры данных

```c
typedef struct {
    // Флаги синхронизации
    volatile int ready;
    volatile int done;

    // Метаданные
    size_t data_size;
    int error_code;

    // Собственно данные
    char buffer[BUFFER_SIZE];
} shared_data_t;
```

### 2. Использование volatile

```c
volatile int flag; // Запрещает компилятору оптимизировать проверки
```

Важно для флагов синхронизации!

### 3. Выравнивание данных

```c
typedef struct {
    int x;
    char c;     // 3 байта padding после c
    int y;
} aligned_struct __attribute__((aligned(4)));
```

### 4. Отладка shared memory

```bash
# Linux: просмотр shared memory объектов
ls -la /dev/shm/

# Просмотр отображенной памяти процесса
cat /proc/[PID]/maps
```

### 5. Обработка сигналов

```c
void cleanup_handler(int sig) {
    munmap(shared_data, SHM_SIZE);
    shm_unlink("/my_shm");
    exit(0);
}

signal(SIGINT, cleanup_handler);  // Ctrl+C
signal(SIGTERM, cleanup_handler); // kill
```

## 16. Архитектура процессов с shared memory

### Схема взаимодействия:

```
┌─────────────────────┐              ┌─────────────────────┐
│  Процесс A          │              │  Процесс B          │
│                     │              │                     │
│  Виртуальная память │              │  Виртуальная память │
│  ┌───────────────┐  │              │  ┌───────────────┐  │
│  │ 0x00100000    │──┼─────┐  ┌─────┼──│ 0x00500000    │  │
│  │ shared region │  │     │  │     │  │ shared region │  │
│  └───────────────┘  │     │  │     │  └───────────────┘  │
└─────────────────────┘     │  │     └─────────────────────┘
                            ↓  ↓
                    ┌──────────────────┐
                    │ Физическая память│
                    │  (Одна область)  │
                    └──────────────────┘
```

### Жизненный цикл shared memory:

1. **Создание** (один процесс):
   
   ```
   shm_open() → ftruncate() → mmap()
   ```

2. **Подключение** (другие процессы):
   
   ```
   shm_open() → mmap()
   ```

3. **Использование** (все процессы):
   
   ```
   Чтение/запись через указатель
   ```

4. **Отключение** (каждый процесс):
   
   ```
   munmap()
   ```

5. **Удаление** (один процесс):
   
   ```
   shm_unlink()
   ```

## 17. Продвинутые техники

### Copy-on-Write (COW)

При `fork()` дочерний процесс получает копии страниц памяти родителя, но физически они общие до первой записи:

```c
int* data = malloc(1000);
pid_t pid = fork();

if (pid == 0) {
    data[0] = 42; // Здесь происходит копирование страницы!
}
```

### Huge Pages

Использование больших страниц памяти (2MB вместо 4KB) для повышения производительности:

```c
mmap(..., MAP_HUGETLB, ...);
```

### Memory-Mapped Files (настоящие файлы)

```c
int fd = open("data.bin", O_RDWR);
char* mapped = mmap(NULL, file_size, PROT_READ | PROT_WRITE, 
                    MAP_SHARED, fd, 0);
// Изменения автоматически сохраняются в файл!
```

---

## Заключение

Этот материал охватывает основные и продвинутые концепции работы с виртуальной памятью и межпроцессным взаимодействием через shared memory. Понимание этих механизмов критически важно для разработки эффективных многопроцессных приложений.

### Ключевые выводы:

- Виртуальная память обеспечивает изоляцию и безопасность
- Shared memory — самый быстрый метод IPC
- Требует явной синхронизации между процессами
- POSIX и Windows API предоставляют схожую функциональность
- Правильная очистка ресурсов критична
