# OS Lab 3 - Межпроцессное взаимодействие через POSIX Shared Memory

## Описание проекта

Программа демонстрирует межпроцессное взаимодействие (IPC) через:
- **POSIX Shared Memory** (разделяемая память в RAM) для передачи данных
- **POSIX Named Semaphores** (именованные семафоры) для синхронизации

Родительский процесс читает числа от пользователя, передаёт их дочернему процессу через разделяемую память в оперативной памяти. Дочерний процесс суммирует числа и записывает результат в выходной файл.

### Ключевые особенности:
- ✅ **Shared Memory в RAM** — данные только в оперативной памяти (не на диске)
- ✅ **Быстрый обмен** — нет операций с диском
- ✅ **Семафоры для синхронизации** — атомарные операции, нет race conditions
- ✅ **Стандарт POSIX** — портативность между UNIX-системами

---

## Компиляция и запуск

### Компиляция:
```bash
gcc -o parent parent.c -lpthread
gcc -o child child.c -lpthread -lm
```

**Важно:** Флаг `-lpthread` необходим для работы с семафорами!

### Запуск:
```bash
./parent
```

Программа запросит имя выходного файла, затем можно вводить числа построчно.  
Пустая строка (Enter) завершает ввод.

---

## Синтаксис и объяснения

---

## 1. POSIX SHARED MEMORY (Разделяемая память)

### Что это?

**POSIX Shared Memory** — это механизм, при котором область памяти в RAM создаётся как объект и может быть доступна нескольким процессам одновременно. Это чистая разделяемая память без привязки к файлу на диске.

**Ключевое отличие от файлов:**
- Данные находятся **только в RAM**
- Нет операций записи на диск
- Быстрее, чем memory-mapped files
- Исчезает при перезагрузке системы

---

### Создание shared memory (`parent.c`)

#### **`shm_unlink(const char *name)`**
```c
shm_unlink(SHM_NAME);
```
- **Назначение:** Удаляет объект POSIX shared memory из системы
- **`name`** — имя объекта (должно начинаться с `/`, например `"/shared_memory"`)
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<sys/mman.h>`
- **Примечание:** Если объект не существует, вернёт `-1` (не критично)
- **Важно:** Физически удаляется, когда все процессы отключат отображение

---

#### **`shm_open(const char *name, int oflag, mode_t mode)`**
```c
int shm_fd = shm_open(SHM_NAME, O_RDWR | O_CREAT | O_EXCL, 0644);
```
- **Назначение:** Создаёт или открывает объект POSIX shared memory
- **Параметры:**
  - `name` — имя объекта (должно начинаться с `/`, например `"/shared_memory"`)
  - `oflag` — флаги открытия (комбинируются через `|`):
    - **`O_RDWR`** — открыть для чтения и записи
    - **`O_CREAT`** — создать объект, если не существует
    - **`O_EXCL`** — вернуть ошибку, если объект уже существует
    - **`O_RDONLY`** — только чтение
  - `mode` — права доступа при создании:
    - **`0644`** = `rw-r--r--` (владелец: чтение+запись, остальные: только чтение)
    - **`0666`** = `rw-rw-rw-` (все: чтение+запись)
    - **`0755`** = `rwxr-xr-x` (владелец: все права, остальные: чтение+исполнение)
- **Возврат:** Файловый дескриптор (целое число ≥ 0) или `-1` при ошибке
- **Заголовок:** `<sys/mman.h>`
- **Важно:** В Linux создаётся в `/dev/shm/` (tmpfs в RAM)

**Как работают права:**
```
0644 = 110 100 100 (binary)
       rw- r-- r--
       |   |   └── Остальные (read)
       |   └────── Группа (read)
       └────────── Владелец (read + write)
```

**Отличие от `open()`:**
```c
// shm_open создаёт объект в RAM (обычно /dev/shm/)
int shm_fd = shm_open("/name", O_RDWR | O_CREAT, 0644);

// open создаёт обычный файл на диске
int fd = open("file.bin", O_RDWR | O_CREAT, 0644);
```

---

#### **`ftruncate(int fd, off_t length)`**
```c
if (ftruncate(shm_fd, SHM_SIZE) == -1) {
```
- **Назначение:** Устанавливает размер объекта shared memory
- **Параметры:**
  - `fd` — файловый дескриптор из `shm_open()`
  - `length` — размер области в байтах (`4096` в нашем случае)
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<unistd.h>`
- **Важно:** Без `ftruncate` объект имеет размер 0, и `mmap` не сможет работать!

---

#### **`mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset)`**
```c
shared_data_t* shared_data = mmap(NULL, SHM_SIZE, 
                                 PROT_READ | PROT_WRITE, 
                                 MAP_SHARED, shm_fd, 0);
```
- **Назначение:** Отображает объект shared memory в адресное пространство процесса
- **Параметры:**
  - **`addr`** — адрес, куда отобразить (обычно `NULL` = система сама выберет)
  - **`length`** — размер отображаемой области в байтах
  - **`prot`** — защита памяти (комбинируются через `|`):
    - **`PROT_READ`** — память доступна для чтения
    - **`PROT_WRITE`** — память доступна для записи
    - **`PROT_EXEC`** — память можно исполнять как код (редко используется)
    - **`PROT_NONE`** — нет доступа
  - **`flags`** — флаги поведения:
    - **`MAP_SHARED`** — изменения видны другим процессам (для IPC!)
    - **`MAP_PRIVATE`** — изменения создают личную копию (copy-on-write)
    - **`MAP_ANONYMOUS`** — не связано с файлом (для памяти между родственными процессами)
  - **`fd`** — файловый дескриптор (из `shm_open`)
  - **`offset`** — смещение от начала (обычно `0`)
- **Возврат:** Указатель на память или **`MAP_FAILED`** (`(void *) -1`) при ошибке
- **Заголовок:** `<sys/mman.h>`

**Как работает `mmap` с shared memory:**
```
Shared Memory (RAM):  [][][][][][][]
                           ↓ mmap
Память процесса:      [][][][][][][]  ← Прямой доступ!
```

**Важно:** С `MAP_SHARED` все процессы видят одну и ту же физическую память в RAM!

**Проверка ошибки:**
```c
if (shared_data == MAP_FAILED) {
    // MAP_FAILED — специальная константа, равная (void *) -1
}
```

---

#### **`close(int fd)`**
```c
close(shm_fd);
```
- **Назначение:** Закрывает файловый дескриптор
- **Параметр:** `fd` — дескриптор для закрытия
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<unistd.h>`
- **Важно:** После успешного `mmap` дескриптор можно закрыть — отображение сохранится!

---

### Открытие существующего shared memory (`child.c`)

```c
int shm_fd = shm_open(SHM_NAME, O_RDWR, 0644);
```
- **Отличие:** Без флага `O_CREAT` — только открывает существующий объект
- Если объект не существует → ошибка (`shm_fd == -1`)
- Родитель создал, ребёнок подключается к той же памяти в RAM

---

#### **`munmap(void *addr, size_t length)`**
```c
munmap(shared_data, SHM_SIZE);
```
- **Назначение:** Отключает отображение shared memory
- **Параметры:**
  - `addr` — адрес начала (вернулся из `mmap`)
  - `length` — размер области
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<sys/mman.h>`
- **Важно:** Освобождает виртуальную память процесса, но **не удаляет объект shared memory**!
- Для удаления используйте `shm_unlink()`

---

## 2. POSIX NAMED SEMAPHORES (Именованные семафоры)

### Что это?

**Семафор** — это примитив синхронизации с целочисленным счётчиком. Используется для координации процессов/потоков.

**Named Semaphore** — семафор с именем, доступный несвязанным процессам через имя в системе.

---

### Основные операции

#### **`sem_open(const char *name, int oflag, mode_t mode, unsigned int value)`**
```c
sem_t *sem_parent = sem_open(SEM_PARENT, O_CREAT | O_EXCL, 0644, 0);
```
- **Назначение:** Создаёт или открывает именованный семафор
- **Параметры:**
  - **`name`** — имя семафора (должно начинаться с `/`)
    - Пример: `"/sem_parent_ready"`
    - В Linux хранятся в `/dev/shm/sem.*`
  - **`oflag`** — флаги:
    - **`O_CREAT`** — создать, если не существует
    - **`O_EXCL`** — вернуть ошибку, если уже существует
    - **`0`** (без флагов) — только открыть существующий
  - **`mode`** — права доступа (как у файлов): `0644`, `0666`
  - **`value`** — **начальное значение счётчика**:
    - `0` = семафор заблокирован (нужен `sem_post` для разблокировки)
    - `1` = семафор свободен (как мьютекс)
    - `N` = может пропустить N процессов одновременно
- **Возврат:** Указатель на `sem_t` или **`SEM_FAILED`** при ошибке
- **Заголовок:** `<semaphore.h>`

**Создание (parent):**
```c
sem_t *sem = sem_open("/my_sem", O_CREAT | O_EXCL, 0644, 0);
//                                          создать  права  счётчик=0
```

**Открытие (child):**
```c
sem_t *sem = sem_open("/my_sem", 0);  // Только открыть
```

---

#### **`sem_wait(sem_t *sem)`**
```c
sem_wait(sem_parent);
```
- **Назначение:** Ждать семафор (P-операция, декремент)
- **Алгоритм:**
  1. Если счётчик > 0 → уменьшить на 1, продолжить выполнение
  2. Если счётчик = 0 → **заблокировать процесс** до `sem_post()`
- **Параметр:** `sem` — указатель на семафор
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<semaphore.h>`
- **Атомарность:** Операция атомарна (нет race conditions)

**Пример:**
```c
// Счётчик = 0
sem_wait(sem);    // Процесс блокируется здесь
// ... ждёт ...
// Другой процесс вызывает sem_post(sem)
// Процесс разблокируется, счётчик остаётся 0
```

---

#### **`sem_post(sem_t *sem)`**
```c
sem_post(sem_child);
```
- **Назначение:** Увеличить счётчик семафора (V-операция, инкремент)
- **Алгоритм:**
  1. Увеличить счётчик на 1
  2. Если есть процессы, ждущие в `sem_wait()` → разблокировать один
- **Параметр:** `sem` — указатель на семафор
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<semaphore.h>`

**Пример:**
```c
// Процесс A:
sem_post(sem);    // Счётчик: 0 → 1, разблокирует процесс B

// Процесс B (был заблокирован в sem_wait):
sem_wait(sem);    // Разблокируется, счётчик: 1 → 0
```

---

#### **`sem_close(sem_t *sem)`**
```c
sem_close(sem_parent);
```
- **Назначение:** Закрывает семафор в текущем процессе
- **Параметр:** `sem` — указатель на семафор
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<semaphore.h>`
- **Важно:** Семафор продолжает существовать в системе для других процессов!

---

#### **`sem_unlink(const char *name)`**
```c
sem_unlink(SEM_PARENT);
```
- **Назначение:** Удаляет именованный семафор из системы
- **Параметр:** `name` — имя семафора (например, `"/sem_parent_ready"`)
- **Возврат:** `0` при успехе, `-1` при ошибке
- **Заголовок:** `<semaphore.h>`
- **Важно:** Физически удаляется, когда все процессы вызовут `sem_close()`

---

### Схема работы семафоров в программе

```
Parent                          Child
  |                              |
  | sem_open(..., 0)  (счёт=0)   | sem_open(..., 0)
  |                              |
  | [записывает данные]          |
  | sem_post(sem_parent) ------> | sem_wait(sem_parent)
  |     (счётчик: 0→1→0)         |     (разблокируется)
  | sem_wait(sem_child)          | [обрабатывает]
  |     (блокируется)            | sem_post(sem_child)
  | <--------------------------  |     (счётчик: 0→1→0)
  |     (разблокируется)         |
```

---

## 3. СТРУКТУРЫ ДАННЫХ

### **Структура в shared memory**

```c
typedef struct {
    char data[SHM_SIZE - 4];
    int data_ready;
} shared_data_t;
```

#### **`typedef struct { ... } name_t;`**
- Определяет пользовательский тип данных
- **`name_t`** — соглашение об именовании (суффикс `_t` = type)

#### **Поля:**
- **`char data[4092]`** — массив символов для передачи данных
- **`int data_ready`** — флаг состояния:
  - `0` = не готово
  - `1` = готово к чтению
  - `2` = конец передачи

#### **Размер структуры:**
```c
sizeof(shared_data_t) = 4092 + 4 = 4096 байт = SHM_SIZE
```

---

## 4. РАБОТА С ПРОЦЕССАМИ

### **`fork(void)`**
```c
pid_t pid = fork();
```
- **Назначение:** Создаёт дочерний процесс (клон текущего)
- **Возврат:**
  - **`-1`** — ошибка создания процесса
  - **`0`** — в дочернем процессе
  - **`> 0`** — PID дочернего процесса в родительском
- **Заголовок:** `<unistd.h>`

**Схема:**
```c
pid_t pid = fork();

if (pid == -1) {
    // Ошибка
} else if (pid == 0) {
    // Код дочернего процесса
} else {
    // Код родительского процесса
    // pid содержит ID дочернего процесса
}
```

---

### **`execl(const char *path, const char *arg0, ..., NULL)`**
```c
execl("./child", "child", NULL);
```
- **Назначение:** Заменяет текущий процесс новой программой
- **Параметры:**
  - **`path`** — путь к исполняемому файлу (`"./child"`)
  - **`arg0`** — `argv[0]` (по соглашению — имя программы)
  - **`...`** — остальные аргументы командной строки
  - **`NULL`** — завершающий маркер (обязательно!)
- **Возврат:** Не возвращает при успехе (процесс заменён), `-1` при ошибке
- **Заголовок:** `<unistd.h>`

**Семейство функций `exec`:**
- **`execl`** — список аргументов: `execl(path, arg0, arg1, ..., NULL)`
- **`execv`** — массив аргументов: `execv(path, argv[])`
- **`execlp`** — поиск в PATH: `execlp("child", "child", NULL)`
- **`execvp`** — массив + PATH

---

### **`wait(int *status)`**
```c
wait(NULL);
```
- **Назначение:** Ждёт завершения любого дочернего процесса
- **Параметр:** `status` — сюда записывается статус завершения (или `NULL`)
- **Возврат:** PID завершившегося процесса или `-1` при ошибке
- **Заголовок:** `<sys/wait.h>`
- **Блокировка:** Родитель блокируется до завершения ребёнка

---

### **`sleep(unsigned int seconds)`**
```c
sleep(1);
```
- **Назначение:** Приостанавливает выполнение на указанное количество секунд
- **Параметр:** `seconds` — количество секунд
- **Возврат:** `0` если отспал всё время, иначе оставшиеся секунды
- **Заголовок:** `<unistd.h>`

---

## 5. БАЗОВЫЕ СИСТЕМНЫЕ ВЫЗОВЫ

### **`read(int fd, void *buf, size_t count)`**
```c
int bytes = read(STDIN_FILENO, buffer, sizeof(buffer) - 1);
```
- **Назначение:** Читает данные из файлового дескриптора
- **Параметры:**
  - `fd` — дескриптор (0=stdin, 1=stdout, 2=stderr, или из `open()`)
  - `buf` — буфер для данных
  - `count` — максимальное количество байт для чтения
- **Возврат:** Количество прочитанных байт, `0` при EOF, `-1` при ошибке
- **Заголовок:** `<unistd.h>`

**Стандартные дескрипторы:**
- **`STDIN_FILENO`** (`0`) — стандартный ввод
- **`STDOUT_FILENO`** (`1`) — стандартный вывод
- **`STDERR_FILENO`** (`2`) — стандартный вывод ошибок

---

### **`write(int fd, const void *buf, size_t count)`**
```c
write(STDOUT_FILENO, "Hello\n", 6);
```
- **Назначение:** Записывает данные в файловый дескриптор
- **Параметры:**
  - `fd` — дескриптор
  - `buf` — буфер с данными
  - `count` — количество байт для записи
- **Возврат:** Количество записанных байт или `-1` при ошибке
- **Заголовок:** `<unistd.h>`

---

## 6. РАБОТА СО СТРОКАМИ

### **`strlen(const char *s)`**
```c
size_t len = strlen(str);
```
- **Назначение:** Вычисляет длину строки (до `'\0'`)
- **Параметр:** `s` — указатель на строку
- **Возврат:** Длина строки (без `'\0'`)
- **Заголовок:** `<string.h>`

---

### **`strncpy(char *dest, const char *src, size_t n)`**
```c
strncpy(shared_data->data, buffer, sizeof(shared_data->data) - 1);
shared_data->data[sizeof(shared_data->data) - 1] = '\0';
```
- **Назначение:** Копирует максимум `n` символов из `src` в `dest`
- **Параметры:**
  - `dest` — буфер назначения
  - `src` — исходная строка
  - `n` — максимальное количество символов
- **Возврат:** Указатель на `dest`
- **Заголовок:** `<string.h>`
- **Важно:** Не гарантирует `'\0'` в конце! Нужно добавлять вручную!

**Безопасный паттерн:**
```c
strncpy(dest, src, SIZE - 1);
dest[SIZE - 1] = '\0';  // Гарантируем null-terminator
```

---

### **`strtod(const char *str, char **endptr)`**
```c
float num = strtod(ptr, &end);
```
- **Назначение:** Конвертирует строку в `double`
- **Параметры:**
  - `str` — указатель на строку
  - `endptr` — сюда записывается указатель на первый неразобранный символ
- **Возврат:** Число или `0.0` при ошибке
- **Заголовок:** `<stdlib.h>`

**Проверка успешности:**
```c
char *end;
float num = strtod(ptr, &end);
if (end != ptr) {
    // Успешно распознали число
    // end указывает на символ после числа
}
```

---

## 7. МАКРОСЫ И КОНСТАНТЫ

### **`#define`**
```c
#define SHM_SIZE 4096
#define SHM_NAME "/shared_memory"
```
- Определяет символическую константу
- Замена происходит на этапе препроцессора (до компиляции)
- **Важно:** Имя для `shm_open` должно начинаться с `/`

---

## 8. АЛГОРИТМ РАБОТЫ ПРОГРАММЫ

### **Инициализация (Parent):**

1. Удаляет старые семафоры: `sem_unlink()`
2. Создаёт два семафора (счётчик=0):
   - `sem_parent` — "данные от parent готовы"
   - `sem_child` — "child обработал данные"
3. Создаёт shared memory: `shm_unlink()` → `shm_open()` → `ftruncate()` → `mmap()`
4. Запрашивает имя выходного файла
5. Записывает имя в shared memory
6. Создаёт дочерний процесс: `fork()`
7. Дочерний процесс заменяется: `execl("./child")`

### **Инициализация (Child):**

1. Открывает существующие семафоры: `sem_open(..., 0)`
2. Открывает shared memory: `shm_open()` → `mmap()`
3. Читает имя выходного файла из shared memory
4. Открывает выходной файл для записи
5. Уведомляет родителя: `sem_post(sem_child)`

### **Основной цикл (Parent):**

1. Читает строку чисел от пользователя: `read(STDIN, ...)`
2. Ждёт освобождения буфера: `sem_wait(sem_child)`
3. Записывает данные в shared memory
4. Уведомляет child: `sem_post(sem_parent)`
5. Повторяет до пустой строки

### **Основной цикл (Child):**

1. Ждёт данные от родителя: `sem_wait(sem_parent)`
2. Проверяет флаг завершения (`data_ready == 2`)
3. Копирует данные из shared memory в локальный буфер
4. Уведомляет родителя: `sem_post(sem_child)`
5. Парсит числа: `strtod()`
6. Суммирует числа
7. Записывает результат в файл: `write(file_fd, ...)`
8. Повторяет до сигнала завершения

### **Завершение:**

**Parent:**
- Ждёт завершения child: `wait(NULL)`
- Очищает ресурсы: `munmap()`, `shm_unlink()`, `sem_close()`, `sem_unlink()`

**Child:**
- Закрывает файлы и семафоры: `close()`, `munmap()`, `sem_close()`
- **Не вызывает** `shm_unlink()` — это делает родитель

---

## 9. ПРИМИТИВ СИНХРОНИЗАЦИИ

**Используется:** Именованные семафоры POSIX (Named Semaphores)

**Тип:** Счётный семафор (counting semaphore)

**Характеристики:**
- ✅ Атомарные операции (нет race conditions)
- ✅ Межпроцессная синхронизация
- ✅ Блокирующее ожидание (процесс спит, не тратит CPU)
- ✅ Событийная модель (семафор = событие)

**Альтернативное название:** "Binary Semaphore Barrier" (барьер на основе бинарных семафоров)

---

## 10. ОТЛИЧИЯ ОТ ДРУГИХ МЕХАНИЗМОВ

### **POSIX Shared Memory vs Memory-mapped file:**

| Характеристика | POSIX Shared Memory | Memory-mapped file |
|----------------|---------------------|-------------------|
| **Создание** | `shm_open()` | `open()` |
| **Где хранится** | Объект в RAM (`/dev/shm/`) | Файл на диске |
| **Персистентность** | Нет (исчезает при перезагрузке) | Да (файл остаётся) |
| **Имя/Путь** | `/shm_name` (начинается с `/`) | `/path/to/file.bin` |
| **Удаление** | `shm_unlink(name)` | `unlink(path)` |
| **Скорость** | Быстрее (только RAM) | Медленнее (диск) |
| **Назначение** | IPC между процессами | Работа с файлами + IPC |

### **Named vs Unnamed Semaphores:**

| Характеристика | Named | Unnamed |
|----------------|-------|---------|
| **Имя** | Имеет (`/sem_name`) | Нет имени |
| **Процессы** | Несвязанные | Родственные |
| **Создание** | `sem_open()` | `sem_init()` |
| **Хранение** | В системе | В shared memory |
| **Удаление** | `sem_unlink()` | `sem_destroy()` |

---

## 11. ОБРАБОТКА ОШИБОК

Все системные вызовы проверяются на ошибки:

```c
if (shm_fd == -1) {
    write_str(STDERR_FILENO, "Error message\n");
    // Очистка ресурсов
    return 1;
}
```

**Стандартные значения ошибок:**
- **`-1`** — большинство функций (`shm_open`, `read`, `write`, и т.д.)
- **`NULL`** — указатели
- **`MAP_FAILED`** — `mmap()`
- **`SEM_FAILED`** — `sem_open()`

---

## 12. КОМПИЛЯЦИЯ С БИБЛИОТЕКАМИ

### **Флаги компиляции:**

```bash
-lpthread   # Линковка с pthread (для семафоров)
-lrt        # Линковка с realtime library (альтернатива -lpthread)
-lm         # Линковка с math library (для математических функций)
```

### **Почему нужен `-lpthread`?**

POSIX семафоры (`sem_*`) и shared memory (`shm_*`) входят в библиотеку `libpthread`, поэтому компилятор должен знать, где искать реализацию этих функций.

---

## Итоговая схема взаимодействия

```
┌─────────────────────────────────────────────────────────┐
│                    PARENT PROCESS                        │
│                                                          │
│  1. Создаёт shared memory в RAM (/dev/shm/)             │
│  2. Создаёт семафоры (sem_parent, sem_child)            │
│  3. fork() → создаёт CHILD                              │
│  4. Записывает данные в shared memory                   │
│  5. sem_post(sem_parent) → уведомляет child             │
│  6. sem_wait(sem_child) → ждёт обработки                │
└────────────────────┬────────────────────────────────────┘
                     │
                     │ Shared Memory (RAM) + Семафоры
                     │
┌────────────────────▼────────────────────────────────────┐
│                    CHILD PROCESS                         │
│                                                          │
│  1. Открывает shared memory                             │
│  2. Открывает семафоры                                  │
│  3. sem_wait(sem_parent) → ждёт данных                  │
│  4. Читает данные из shared memory                      │
│  5. Обрабатывает (парсинг + суммирование)               │
│  6. Записывает результат в выходной файл                │
│  7. sem_post(sem_child) → уведомляет parent             │
└─────────────────────────────────────────────────────────┘
```

---

## Глоссарий

- **IPC** — Inter-Process Communication (межпроцессное взаимодействие)
- **POSIX Shared Memory** — разделяемая память в RAM для IPC
- **Memory-mapped file** — файл на диске, отображённый в память
- **Semaphore** — примитив синхронизации со счётчиком
- **Named semaphore** — семафор с именем для несвязанных процессов
- **File descriptor** — целое число, идентифицирующее открытый файл/объект
- **Atomic operation** — операция, выполняющаяся неделимо
- **Race condition** — ошибка синхронизации при конкурентном доступе
- **Blocking** — операция, приостанавливающая процесс до события
- **tmpfs** — временная файловая система в RAM (где `/dev/shm/`)

---

## Ссылки на документацию

- **`man 3 shm_open`** — создание/открытие shared memory
- **`man 3 shm_unlink`** — удаление shared memory
- **`man 2 mmap`** — отображение в память
- **`man 3 sem_open`** — семафоры POSIX
- **`man 2 fork`** — создание процессов
- **`man 3 execl`** — замена процесса

---

## Автор

Лабораторная работа по операционным системам  
МАИ, 3 семестр
